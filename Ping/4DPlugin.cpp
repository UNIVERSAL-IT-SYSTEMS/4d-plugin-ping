/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Ping
 #	author : miyako
 #	2015/01/29
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

#if VERSIONWIN
bool isProcessOnExit(){    
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    return (0 == PA_CompareUnichars((PA_Unichar *)name.getUTF16StringPtr(), (PA_Unichar *)L"$xx", 1, 0));
}
#endif

void GetAddressIpv4(sockaddr_in *sockaddr_ipv4, CUTF8String *address_ip){
    
#if VERSIONMAC	
    char address_ipv4[INET_ADDRSTRLEN];
    if(inet_ntop(AF_INET, (const void *)&sockaddr_ipv4->sin_addr, address_ipv4, INET_ADDRSTRLEN))
        *address_ip = (const uint8_t *)address_ipv4;					
#else
    //inet_ntop requires vista or later
    //http://msdn.microsoft.com/en-us/library/windows/desktop/cc805843(v=vs.85).aspx
    *address_ip = (const uint8_t *)inet_ntoa(sockaddr_ipv4->sin_addr);
#endif	
    
}

double Milliseconds(){
    
    double ms = 0;
    
#if VERSIONMAC	
    Nanoseconds ns = AbsoluteToNanoseconds(UpTime());  
    ms = UnsignedWideToUInt64(ns) / 1000000.0;
#else
    
    LARGE_INTEGER stamp, freq;
    if(QueryPerformanceFrequency(&freq)){
        QueryPerformanceCounter(&stamp);
        ms = (stamp.QuadPart * 1000.0) / (double)freq.QuadPart;
    }else{
        ms = timeGetTime();
    }
#endif	
    return ms;
}

void IntToString(int num, CUTF8String *numStr){
    
    char str[12];
    sprintf(str, "%d", num);
    *numStr = (const uint8_t *)str;
}

void MakeTimeoutMessage(int seqId, CUTF8String *message){
    
    CUTF8String seqIdStr;
    IntToString(seqId, &seqIdStr);
    
    *message = (const uint8_t *)"";
    *message += (const uint8_t *)"Request timeout for icmp_seq ";
    *message += seqIdStr;	
}

double DiffMs(double endMs, double startMs){
    
    double ms = 0;
    
    if(endMs>startMs)
        ms =  endMs - startMs;
    
    if(endMs<startMs)
        ms =  endMs + DBL_MAX - startMs;
    
    return ms;
}

void DoubleToString(double num, CUTF8String *numStr){
    
    char str[12];
    sprintf(str, "%.3f", num);
    *numStr = (const uint8_t *)str;
}

void MakeResponseMessage(int bytes, int ttl, int seqId, double startMs, CUTF8String *address_ip, CUTF8String *message){
    
    CUTF8String seqIdStr, timeStr, bytesStr, ttlStr;
    IntToString(seqId, &seqIdStr);
    IntToString(bytes, &bytesStr);	
    IntToString(ttl, &ttlStr);		
    DoubleToString(DiffMs(Milliseconds(), startMs), &timeStr);
    
    *message += bytesStr;
    *message += (const uint8_t *)" bytes from ";
    *message += *address_ip;
    *message += (const uint8_t *)": icmp_seq=";
    *message += seqIdStr;										
    *message += (const uint8_t *)" ttl=";										
    *message += ttlStr;
    *message += (const uint8_t *)" time=";	
    *message += timeStr;	
    *message += (const uint8_t *)" ms";	
    
}

#if VERSIONWIN
int SendReceiveEchoResponse(IPAddr ipaddr, socklen_t socklen, int timeOut, int seqId, int *bytes, int *ttl){
    
    int err	= 0;	
    int nRet;
    
    static ECHOREQUEST echoReq;
    
    echoReq.icmpHdr.Type		= ICMP_ECHOREQ;
    echoReq.icmpHdr.Code		= 0;
    echoReq.icmpHdr.Checksum	= 0;
    echoReq.icmpHdr.ID			= (u_short)getpid();
    echoReq.icmpHdr.Seq			= seqId;	
    
    for (nRet = 0; nRet < REQ_DATASIZE; nRet++)
        echoReq.cData[nRet] = ' '+nRet;
    
    echoReq.dwTime = (unsigned int)time(NULL);	
    echoReq.icmpHdr.Checksum = in_cksum((u_short *)&echoReq, sizeof(ECHOREQUEST));
    
    char echoReply[sizeof(ICMP_ECHO_REPLY) + sizeof(ECHOREQUEST)];
    
    HANDLE hIcmpFile = INVALID_HANDLE_VALUE;
    
    DWORD dwRetVal = 0;
    
    switch (socklen){
        case sizeof(struct sockaddr_in):
            hIcmpFile = IcmpCreateFile();
            break;
        case sizeof(struct sockaddr_in6):
            /*
             //http://msdn.microsoft.com/en-us/library/windows/desktop/aa366037(v=vs.85).aspx
             */
            break;			
        default:
            break;
    }
    
    if(hIcmpFile == INVALID_HANDLE_VALUE){
        err = GetLastError();
    }else{
        
        switch (socklen){
            case sizeof(struct sockaddr_in):
                dwRetVal = IcmpSendEcho(hIcmpFile, 
                                        ipaddr, 
                                        (LPVOID)&echoReq, 
                                        sizeof(ECHOREQUEST),
                                        NULL, 
                                        (LPVOID)echoReply,
                                        sizeof(ICMP_ECHO_REPLY) + sizeof(ECHOREQUEST), 
                                        timeOut * 1000);
                break;
            case sizeof(struct sockaddr_in6):	
                /*
                 //https://groups.google.com/forum/?fromgroups#!topic/microsoft.public.platformsdk.networking.ipv6/oVEPqBsvHyQ%5B1-25%5D
                 */
                break;
            default:
                break;
        }
        
        if(dwRetVal){
            
#ifdef _WIN64
            PICMP_ECHO_REPLY32 pEchoReply = (PICMP_ECHO_REPLY32)echoReply;
#else
            PICMP_ECHO_REPLY pEchoReply = (PICMP_ECHO_REPLY)echoReply;
#endif
            pEchoReply->RoundTripTime;
            
            if(pEchoReply->Status == IP_SUCCESS){
                *bytes = pEchoReply->DataSize + 19;	
                *ttl = pEchoReply->Options.Ttl;				
            }			
        }else{
            err = GetLastError();
            if(err == IP_REQ_TIMED_OUT)
                err = -1;
        }	
        
        IcmpCloseHandle(hIcmpFile);
        
    }
    
    return err;	   
}	   
#endif

int SendReceiveEchoResponse(SOCKET sock, const struct sockaddr *addr, socklen_t socklen, int limit, int seqId, int *bytes, int *ttl){
    
    int err = 0;
    
    if(sock != INVALID_SOCKET){
        
        err = SendEchoRequest(sock, addr, socklen, seqId);
        
        if(!err)
            err = ReceiveEchoResponse(sock, addr, socklen, limit, seqId, bytes, ttl);
        
    }
    
    return err;
}

int SendEchoRequest(SOCKET sock, const struct sockaddr *addr, socklen_t socklen, int seqId){
    
    int err	= 0;
    int nRet;
    
    static ECHOREQUEST echoReq;
    
    echoReq.icmpHdr.Type		= ICMP_ECHOREQ;
    echoReq.icmpHdr.Code		= 0;
    echoReq.icmpHdr.Checksum	= 0;
    echoReq.icmpHdr.ID			= (u_short)getpid();
    echoReq.icmpHdr.Seq			= seqId;
    
    for (nRet = 0; nRet < REQ_DATASIZE; nRet++)
        echoReq.cData[nRet] = ' '+nRet;
    
    echoReq.dwTime = (unsigned int)time(NULL);	
    echoReq.icmpHdr.Checksum = in_cksum((u_short *)&echoReq, sizeof(ECHOREQUEST));
    
    nRet = sendto(sock,						
                  (const char *)&echoReq,			
                  sizeof(ECHOREQUEST),
                  0,							
                  (const struct sockaddr *)addr, 
                  socklen);
    
    if (nRet == SOCKET_ERROR){ 
#if VERSIONWIN
        err = WSAGetLastError();
#else
        err = errno;
#endif
    }else{
        if(nRet	!= sizeof(ECHOREQUEST))
            err = 1;//EPERM(1) in original IC
    }
    
    return err;
}

int ReceiveEchoResponse(SOCKET sock, const struct sockaddr *addr, socklen_t socklen, int timeOut, int seqId, int *bytes, int *ttl){
    
    ECHOREPLY echoReply;
    int err	= 0;
    int nRet;	
    socklen_t len = socklen;
    *bytes = 0;
    *ttl = 0;
    fd_set fds;
    int n;
    
    bind(sock, (struct sockaddr *)&addr, socklen);
    
    FD_ZERO(&fds);
    FD_SET(sock, &fds);
    
    struct timeval tv;
    tv.tv_sec = timeOut;
    tv.tv_usec = 0;
    
    n = select(sock+1, &fds, NULL, NULL, &tv);
    
    if(!n)
        err = -1;//reached timeout
    
    if(!err){
        
        if(FD_ISSET(sock, &fds)){
            
            nRet = recvfrom(sock, 
                            (char *)&echoReply,
                            sizeof(ECHOREPLY), 
                            0,
                            (struct sockaddr *)addr, 
                            &len);
            
            if (nRet == SOCKET_ERROR){ 
#if VERSIONWIN
                err = WSAGetLastError();
#else
                err = errno;
#endif
            }
        }		
        
        if(!err){		
            if(echoReply.echoRequest.icmpHdr.Type == ICMP_ECHOREPLY){
                if(echoReply.echoRequest.icmpHdr.ID == getpid()){
                    if(echoReply.echoRequest.icmpHdr.Seq == seqId){
                        *bytes = nRet-1;
                        *ttl = echoReply.ipHdr.TTL;					
                    }
                }
            }
        }		
    }
    
    return err;
}

u_short in_cksum(u_short *addr, int len)
{
    register int nleft = len;
    register u_short *w = addr;
    register u_short answer;
    register int sum = 0;
    
    /*
     *  Our algorithm is simple, using a 32 bit accumulator (sum),
     *  we add sequential 16 bit words to it, and at the end, fold
     *  back all the carry bits from the top 16 bits into the lower
     *  16 bits.
     */
    while( nleft > 1 )  {
        sum += *w++;
        nleft -= 2;
    }
    
    /* mop up an odd byte, if necessary */
    if( nleft == 1 ) {
        u_short	u = 0;
        
        *(u_char *)(&u) = *(u_char *)w ;
        sum += u;
    }
    
    /*
     * add back carry outs from top 16 bits to low 16 bits
     */
    sum = (sum >> 16) + (sum & 0xffff);	/* add hi 16 to low 16 */
    sum += (sum >> 16);			/* add carry */
    answer = ~sum;				/* truncate to 16 bits */
    return (answer);
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- IC Internet
		case kInitPlugin :
		case kServerInitPlugin :            
#if VERSIONWIN
            WSADATA wsaData;
            WSAStartup(MAKEWORD(2,0), &wsaData);
#endif            
			break;

        case kCloseProcess :            
#if VERSIONWIN
            if(isProcessOnExit()){
                WSACleanup();
            }
#endif             
            break;            
		case 1 :
			HOST_Ping(pResult, pParams);
			break;

	}
}

// ---------------------------------- IC Internet ---------------------------------


void HOST_Ping(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT hostName;
    ARRAY_TEXT responses;
    C_LONGINT pLimit;
    C_LONGINT pCount;
    C_LONGINT returnValue;
    
    hostName.fromParamAtIndex(pParams, 1);
    responses.setSize(1);
    pCount.fromParamAtIndex(pParams, 3);	
    pLimit.fromParamAtIndex(pParams, 4);	
    int count = pCount.getIntValue();
    int limit = pLimit.getIntValue();	
    
    if(count < 1)
        count = 1;
    
    if(limit < 1)
        limit = 1;
    
    CUTF8String host;
    hostName.copyUTF8String(&host);
    
    struct addrinfo hints, *res, *res0;
    
    int err;
    int seqId;
    bool done = false;
    
    SOCKET sock;
    
    struct sockaddr_in  *sockaddr_ipv4;
    //	struct sockaddr_in6 *sockaddr_ipv6;
    
    memset(&hints, 0, sizeof(hints));
    
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_UNSPEC;
    
    if((err = getaddrinfo((const char *)host.c_str(), NULL, &hints, &res0))){
        returnValue.setIntValue(err);
    }else{
        
        for(res = res0; res != NULL && (!done); res = res->ai_next){
            PA_YieldAbsolute();
            sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
            if(sock == INVALID_SOCKET){
                continue;
            }
            
            close(sock);
            
            CUTF8String address_ip;
            
            int bytes, ttl;
            double startMs;
            
            switch(res->ai_family){
                    
                case AF_INET:
                    
                    sockaddr_ipv4 = (struct sockaddr_in *)res->ai_addr;
                    GetAddressIpv4(sockaddr_ipv4, &address_ip);
                    
#if VERSIONMAC	
                    struct sockaddr_in addr_ipv4;
                    memset(&addr_ipv4, 0, sizeof(addr_ipv4));
                    sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
                    addr_ipv4.sin_addr.s_addr = sockaddr_ipv4->sin_addr.s_addr;
                    addr_ipv4.sin_family = AF_INET;
#endif	
                    
                    for(seqId = 1; seqId <= count; ++seqId){
                        
                        PA_YieldAbsolute();
                        
                        startMs = Milliseconds();
#if VERSIONWIN						
                        err = SendReceiveEchoResponse(sockaddr_ipv4->sin_addr.s_addr, sizeof(struct sockaddr_in), limit, seqId, &bytes, &ttl);	
#else						
                        err = SendReceiveEchoResponse(sock, (const struct sockaddr *)&addr_ipv4, sizeof(struct sockaddr_in), limit, seqId, &bytes, &ttl);
#endif							
                        CUTF8String message;
                        
                        switch (err){
                            case -1:
                                MakeTimeoutMessage(seqId, &message);
                                responses.appendUTF8String(&message);
                                break;
                            case 0:	
                                MakeResponseMessage(bytes, ttl, seqId, startMs, &address_ip, &message);
                                responses.appendUTF8String(&message);
                                break;
                            default:
                                returnValue.setIntValue(err);
                                break;
                        }		
                    }					
#if VERSIONMAC					
                    close(sock);
#endif								
                    break;	
                case AF_INET6:
                    /*
                     sockaddr_ipv6 = (struct sockaddr_in6 *) res->ai_addr;
                     GetAddressIpv6(sockaddr_ipv6, &address_ip);					 
                     */
                    break;					
                default:
                    break;						
            }
        }
        
        freeaddrinfo(res0);		
    }
    
    responses.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);	
}

